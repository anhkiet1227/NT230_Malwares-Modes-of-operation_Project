import random
import string
import pefile
import subprocess

def overlay_append(file_path, overlay_file_path):
    with open(overlay_file_path, "rb") as overlay_file:
        overlay_content = overlay_file.read()
        with open(file_path, "ab") as file:
            file.write(overlay_content)

    return file_path


def imports_append(file_path, imports):
    pe = pefile.PE(file_path)
    pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])

    # Choose a random import descriptor
    import_descriptor = random.choice(pe.DIRECTORY_ENTRY_IMPORT)

    # Add the imports to the chosen import descriptor
    for imp in imports:
        import_descriptor.imports.append(imp)

    # Save the modified PE file
    output_file_path = file_path.rstrip('.exe') + '_imports.exe'
    pe.write(output_file_path)

    return output_file_path


def section_rename(file_path, section_name, new_name):
    pe = pefile.PE(file_path)

    # Find the section by name
    section = None
    for sec in pe.sections:
        if sec.Name.decode().strip('\x00') == section_name:
            section = sec
            break

    if section is not None:
        # Rename the section
        section.Name = new_name.encode()

        # Save the modified PE file
        output_file_path = file_path.rstrip('.exe') + '_section_rename.exe'
        pe.write(output_file_path)

        return output_file_path

    else:
        print(f"Section '{section_name}' not found in the PE file.")
        return None



def section_add(file_path, section_name):
    # Generate a random section size (in hexadecimal)
    section_size = random.randint(1024, 4096)

    pe = pefile.PE(file_path)

    # Create a new section
    new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
    new_section.Name = section_name.encode()
    new_section.VirtualAddress = pe.sections[-1].VirtualAddress + pe.sections[-1].Misc_VirtualSize
    new_section.Misc_VirtualSize = section_size
    new_section.SizeOfRawData = section_size
    new_section.PointerToRawData = pe.sections[-1].PointerToRawData + pe.sections[-1].SizeOfRawData

    # Add the new section to the PE file
    pe.sections.append(new_section)

    # Update the section count in the PE header
    pe.FILE_HEADER.NumberOfSections = len(pe.sections)

    # Save the modified PE file
    output_file_path = file_path.rstrip('.exe') + '_section_add.exe'
    pe.write(output_file_path)

    return output_file_path



def section_append(file_path, section_name, content):
    pe = pefile.PE(file_path)

    # Find the section by RVA
    section = None
    for sec in pe.sections:
        if sec.VirtualAddress == pe.get_section_by_rva(sec.VirtualAddress).VirtualAddress:
            section = sec
            break

    if section is not None:
        # Append content to the section
        section_data = section.get_data()
        section_data += content

        # Update the section size
        section.SizeOfRawData = len(section_data)
        section.Misc_VirtualSize = len(section_data)

        # Save the modified PE file
        output_file_path = file_path.rstrip('.exe') + '_section_append.exe'
        pe.write(output_file_path)

        return output_file_path

    else:
        print(f"Section '{section_name}' not found in the PE file.")
        return None



def remove_signature(file_path):
    pe = pefile.PE(file_path)

    # Remove the certificate table directory entry
    if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY'):
        pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress = 0
        pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size = 0

    # Save the modified PE file
    output_file_path = file_path.rstrip('.exe') + '_remove_signature.exe'
    pe.write(output_file_path)

    return output_file_path



def remove_debug(file_path):
    pe = pefile.PE(file_path)

    # Clear the DebugDirectory
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_DEBUG']].VirtualAddress = 0
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_DEBUG']].Size = 0

    # Save the modified PE file
    output_file_path = file_path.rstrip('.exe') + '_remove_debug.exe'
    pe.write(output_file_path)

    return output_file_path


def upx_pack(file_path):
    # Provide the full path to the UPX executable
    upx_path = "./upx-win/upx-4.0.2-win64/upx.exe"
    #upx_path = "./upx-linux/upx"
    # Run UPX packer on the specified file
    packed_file_path = file_path.rstrip('.exe') + '_upx_packed.exe'
    subprocess.run([upx_path, '-o', packed_file_path, file_path])

    return packed_file_path



def upx_unpack(file_path):
    # Provide the full path to the UPX executable
    upx_path = "./upx-win/upx-4.0.2-win64/upx.exe"
    #upx_path = "./upx-linux/upx"
    # Run UPX unpacker on the specified file
    unpacked_file_path = file_path.rstrip('_upx_packed.exe') + '_upx_unpacked.exe'
    subprocess.run([upx_path, '-d', '-o', unpacked_file_path, file_path])

    return unpacked_file_path



def break_header(file_path):
    with open(file_path, "rb+") as file:
        file.seek(0)
        file.write(random.choice(string.ascii_letters).encode())

    return file_path


def apply_random_perturbation(file_path):
    perturbation_methods = [
        overlay_append,
        imports_append,
        section_rename,
        section_add,
        section_append,
        remove_signature,
        remove_debug,
        upx_pack,
        upx_unpack,
        break_header,
    ]

    # Choose a random perturbation method
    #perturbation = random.choice(perturbation_methods)
    perturbation = break_header
    
    if perturbation == section_rename: 
        # Generate random section name
        section_name = "".join(random.choice(string.ascii_letters) for _ in range(8))
        output_file = perturbation(file_path, section_name, section_name + "_renamed")
    elif perturbation == section_add:
        section_name = "".join(random.choice(string.ascii_letters) for _ in range(8))
        output_file = perturbation(file_path, section_name)
    elif perturbation == section_append:
        # Generate random section name and content
        section_name = "".join(random.choice(string.ascii_letters) for _ in range(8))
        content = bytes([random.randint(0, 255) for _ in range(1024)])
        output_file = perturbation(file_path, section_name, content)
    elif perturbation == overlay_append:
        # Provide path to overlay file
        overlay_file_path = "./perturb/putty.exe"
        output_file = perturbation(file_path, overlay_file_path)
    elif perturbation == imports_append:
        # Provide list of imports
        imports = ["kernel32.dll", "user32.dll"]
        output_file = perturbation(file_path, imports)
    else:
        output_file = perturbation(file_path)

    print(f"Perturbation {perturbation.__name__} applied to file {file_path}")
    print(f"Output file: {output_file}")


# Usage example
#file_path = "./orginal/putty_upx_packed.exe"
file_path = "./orginal/putty.exe"
#file_path = "./orginal/x0r.exe"
apply_random_perturbation(file_path)